/**
 * @class Phorum.UI.NewFlags
 * @extends Object
 *
 * <p>
 *   The Phorum.UI.NewFlags singleton implements a framework for handling
 *   newflags in Phorum. It provides features to to handle "mark read" actions
 *   through Ajax communication to the server and to update the user interface
 *   after a "mark read" Ajax call has completed successfully.
 * </p>
 * <p>
 *   For templates to support handling mark new actions through Ajax, they have
 *   to include calls to {@link #markRead Phorum.UI.NewFlags.markRead()} or
 *   the shorter alias {@link Phorum#markRead Phorum.markRead()}.
 * </p>
 * <p>
 *   For updating the user interface after a successful call, a few built-in
 *   methods are provided. See {@link #updateUI updateUI()} for a description
 *   of these. If a template or module author needs support for a method that
 *   is not built-in, extra methods can be implemented by registering a
 *   callback through {@link #registerCallback registerCallback()}.
 * </p>
 *
 * @singleton
 */
Phorum.UI.NewFlags = {

    /**
     * @property className
     * @private
     */
    className: 'Phorum.UI.NewFlags',

    /**
     * <p>
     *   This is the callback registry. It holds callback functions that
     *   will be called when a {@link #markRead Phorum.UI.NewFlags.markRead()}
     *   call has been executed successfully.
     * </p>
     *
     * @private
     */
    callbacks: [ ],

    /**
     * <p>
     *   Register a callback that has to be called after a
     *   {@link #markRead markRead()} call has been completed successfully.
     * </p>
     * <p>
     *   By means of callbacks, templates and modules can add handling code
     *   for updating the user interface after marking messages read (e.g. the
     *   announcement module, which needs customized handling for marking
     *   messages in the announcements block as read when the user clicks on
     *   "mark read" for the announcement forum on the index page).
     * </p>
     * <p>
     *   The registered callback functions will be called with two parameters,
     *   which identify the messages that have been marked read:
     * </p>
     * <div class="mdetail-params"><ul>
     *   <li><b>mode</b>: "forums", "threads" or "messages"</li>
     *   <li><b>item_id</b>: the forum, thread or message id/li>
     * </ul></div>
     * 
     * @param {Function} callback
     *   The callback function to register.
     */
    registerCallback: function (callback)
    {
        this.callbacks.push(callback);
    },

    /**
     * <p>
     *   This method can be called from "mark read" links to handle marking
     *   forums, threads or messages read through Ajax calls. After the
     *   call has finished successfully, the
     *   {@link #registerCallback registered callbacks} will be called to
     *   update the user interface.
     * </p>
     * <p>
     *   This method is also available through the alias
     *   {@link Phorum#markRead Phorum.markRead()}.
     * </p>
     *
     * @param {String} mode
     *     One of "forums", "threads" or "messages".
     *
     * @param {Integer} item_id
     *     A forum_id, thread id or message_id (which one to use depends
     *     on the "mode" parameter).
     */
    markRead: function (mode, item_id)
    {
        // Request busy notification for the user.
        Phorum.UI.BusyMarker.increment();

        var request = {
            'call': 'markread',
            'onSuccess': function (data) {
                Phorum.UI.BusyMarker.decrement();
                Phorum.UI.NewFlags.updateUI(mode, item_id);
            },
            'onFailure': function (data) {
                Phorum.UI.BusyMarker.decrement();
            }
        };

        // Because the "mode" is dynamic ("forums", "threads" or "messages"),
        // we have to assign this property of the request like this.
        request[mode] = [ item_id ];

        Phorum.debug(
            this.className + ': call markread for mode = ' + mode + ', ' +
            'id = ' + item_id, 5
        );

        // Dispatch the Ajax Phorum call.
        Phorum.call(request);

        // So "return Phorum.UI.NewFlags.markRead(...)" can be used to cancel
        // an <a href> click.
        return false;
    },

    /**
     * <p>
     *   Update the user interface after marking messages as read.
     * </p>
     * <p>
     *   This method implements a few basic methods for updating the
     *   user interface. If a template or module needs extra methods,
     *   then the {@link #registerCallback registerCallback()}
     *   method can be used to implement extra methods.
     * </p>
     * <p>
     *   <b>Built-in UI update methods:</b>
     * </p>
     * <p>
     *   Below, we describe what update methods are provided by this class.
     *   In the descriptions, you will find references to &lt;item&gt;. At
     *   places where you see this, you can define the item to which the new
     *   flag is linked. The format is:
     *   <pre><code>
&lt;forum id&gt;[, &lt;thread id&gt;[, &lt;message id&gt;]]

&lt &gt = mandatory
[ ] = optional

Examples:
new-flag[10] = forum 10, for example on the index page
new-flag[10,5] = forum 10, thread 5, for example on the list page
new-flag[10,5,84] = forum 10, thread 5, message 85, for example on the read page
     *   </code></pre>
     * </p>
     * <div class="mdetail-params"><ul>
     *   <li>
     *     <b>New-flag</b>:<br/>
     *     In the default Phorum template, this is the red "new" text that
     *     is shown for new messages. When the related item is marked read,
     *     then the new flag is hidden. To implement this in a template, use
     *     the following template:<br/>
     *     <pre><code>
&lt;span class="new-flag[&lt;item&gt;]"&gt;
  ... new-flag representation code goes here ...
&lt;span&gt;

For example:

&lt;span class="new-flag[10,5,84] new-flag"&gt;new&lt;/span&gt;
     *     </code></pre>
     *   </li>
     * </ul></div>
     *
     * @param {String} mode
     *     One of "forums", "threads" or "messages".
     *
     * @param {Array} item_id
     *     The forum, thread or message id (which one to use depends
     *     on the "mode" parameter).
     */
    updateUI: function (mode, item_id)
    {
        Phorum.debug(
            this.className + ': update UI for mode = ' + mode + ', ' +
            'id = ' + item_id, 5
        );

        // Method: new-flag
        // Action: Hide the new-flag element
        this.processMatchingElements(
            'span', 'new-flag', mode, item_id,
            function (elt) {
                $PJ(elt).fadeOut();
            }
        );

        // Call all registered new flag cleanup callback functions.
        for (var i = 0; i < this.callbacks.length; i++) {
            this.callbacks[i](mode, item_id);
        }
    },

    /**
     * <p>
     *   Utility method for finding new-flag elements for which to run
     *   a callback function.
     * </p>
     * <p>
     *   This method is marked as private, but template and module writers
     *   that need this functionality as well can of course make use of it.
     * </p>
     * 
     * @param {String} tag
     *     The tag to search on (e.g. "span").
     * @param {String} type
     *     The type of new-flag (e.g. "new-flag" or "new-subject").
     * @param {String} mode
     *     One of "forums", "threads" or "messages".
     * @param {Integer} item_id
     *     A forum_id, thread id or message_id (which one to use depends
     *     on the "mode" parameter).
     * @param {Function} callback
     *     The callback function to call for each matching element
     *     in the page. The callback function will receive the matching
     *     element as its argument.
     * @private
     */
    processMatchingElements: function (tag, type, mode, item_id, callback)
    {
        // Build the regular expression for matching the class name that is used
        // in the page for representing type + mode + item_id.
        var regexp = '^' + type + '\\[';
        switch (mode) {
        case "forums"   : regexp += item_id + '(,\\d+){0,2}'; break;
        case "threads"  : regexp += '\\d+,' + item_id + '(,\\d+)?'; break;
        case "messages" : regexp += '\\d+,\\d+,' + item_id; break;
        default         : throw this.className + ': ' +
                          'processMatchingTags(): illegal mode: ' + mode;
        }
        regexp += '\\]';
        var re = new RegExp();
        re.compile(regexp);

        // Find for the provided tag (e.g. "span") all elements that have
        // "<type>[" somewhere in the class name. These are candidates
        // for matching the full "<type>[<item>]" format.
        var selector = '"' + tag + "[class*='" + type + "[']\"";
        $PJ(selector).each(function ()
        {
            // Elements might have more than one class name assigned to them.
            // Inspect each class name separately.
            var classes = $PJ(this).attr('class').split(' ');
            for (var i = 0; i < classes.length; i++) {
                // If we find a match, we call the callback method and
                // stop inspecting the class names for the current element.
                if (re.test(classes[i])) {
                    callback(this);
                    break;
                }
            }
        });
    }
};

